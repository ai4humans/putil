# test.py
# Copyright (c) 2013-2015 Pablo Acosta-Serafini
# See LICENSE for details
# pylint: disable=C0111

import re
import sys
import pytest
import contracts

import putil.check
import putil.misc


def evaluate_command_value_series(cmd_pairs, cobj=None):
	""" Evaluates results of a series of command/value/result cases """
	# Convert to list if a single tuples is given (if necessary)
	cmd_pairs = cmd_pairs if isinstance(cmd_pairs, list) else [cmd_pairs]
	# Add object to list of tuples (if necessary)
	cmd_pairs = [(cobj, )+cmd_item for cmd_item in cmd_pairs] if cobj else cmd_pairs
	# Create list of (expected values, actual values) pretty printed tuples
	exolist = [evaluate_value_series(cmd, (value, result), num, return_or_assert=False) for num, (cmd, value, result) in enumerate(cmd_pairs)]
	expected_msg, actual_msg = '\n'.join(element[0] for element in exolist), '\n'.join(element[1] for element in exolist)
	# Evaluate results
	assert expected_msg == actual_msg


def evaluate_contains_series(cspec_list, cobj=None, offset=0):
	""" Evaluates results of a command with multiple argument/value cspec_list """
	# Convert to list if a single tuples is given (if necessary)
	cspec_list = cspec_list if isinstance(cspec_list, list) else [cspec_list]
	# Add object to list of tuples (if necessary)
	cspec_list = [(cobj, )+cspec_item for cspec_item in cspec_list] if cobj else cspec_list
	# Evaluate contains specification list and produce readable test list
	expected_list = list()
	actual_list = list()
	comp_text = '[{0}] {1} in {2} == {3}'
	for num, (cobj, value, expected_result) in enumerate(cspec_list):
		# Test __contains__
		actual_result = value in cobj
		# Produce expected and actual pretty printed results
		expected_list.append(comp_text.format(num+offset, value, cobj, expected_result))
		actual_list.append(comp_text.format(num+offset, value, cobj, actual_result))
	# Produce final actual vs. expected pretty printed list
	expected_msg, actual_msg = '\n'.join(expected_list), '\n'.join(actual_list)
	# Evaluate results
	assert expected_msg == actual_msg


def evaluate_exception_method(emspec_list, cobj=None, offset=0, ekwargs=None):	#pylint: disable=R0914
	"""
	Test argument validation pseudo-type exception method

	:param	emspec_list: Exception method specification
	:type	emspec_list: tuple or list
	:param	cobj: Pseudo-type class. If present all items of **emspec_list** are tested with the same class
	:type	cobj: class
	:param	offset: Comparison list offset. Each item in **emspec_list** is numbered starting from 0 or **offset**, if given
	:type	offset: integer
	:param	ekwargs: Exception method keyword arguments. If not given all items of **empsec_list** are tested with ``{'param_name':'par1'}``
	:type	ekwargs: dictionary

	There is flexibility in specifying how the class ``.exception()`` method is to be called and evaluated. The most general exception specification tuple of **emspec_list** is:

	``(tcobj=cobj, kwargs=None, etype, emsg, tekwargs=ekwargs)``
	 * **tcobj** `(class)` -- Pseudo-type class. Can be ommitted here and given in the function argument **cobj** if all items in **emspec_list** are to be evaluated using the same class

	 * **ckwargs** `(dictionary)` -- Arguments required for pseudo-type initialization. `None` or empty object if not needed, can be omitted if no arguments are required to initialize the pseudo-type

	 * **etype** `(type)` -- Exception type (i.e. `RuntimeError`, `ValueError`, etc.). `None` if no exception is generated by pseudo-type

	 * **emsg** `(string)` -- Exception message. `''` if no exception is generated by pseudo-type

	 * **tekwargs** `(dictionary)` -- Exception method keyword arguments. The keys can only be `'param'` and/or `'param_name'`. Can be omitted here and given in the function argument **ekwargs** if all items in **emspec_list**
	   are to be evaluated using the same exception method arguments, or if **ekwargs** is absent, it is set to ``{'param_name':'par1'}``

	"""
	# Convert to list if a single tuples is given (if necessary)
	emspec_list = emspec_list if isinstance(emspec_list, list) else [emspec_list]
	# Add object to list of tuples (if necessary)
	emspec_list = [(cobj, )+emspec_item for emspec_item in emspec_list] if cobj else emspec_list
	# Add None as argument list (if necessary)
	new_emspec_list = list()
	for num, item in enumerate(emspec_list):
		print '{0}: {1}'.format(num, item)
		print
	for emspec_item in emspec_list:
		if len(emspec_item) == 3:
			emspec_item = list(emspec_item)
			emspec_item.insert(1, None)
			emspec_item = tuple(emspec_item)
		if (len(emspec_item) == 4) and (not isinstance(emspec_item[-1], dict)):
			ekwargs = {'param_name':'par1'} if not ekwargs else ekwargs
			emspec_item = list(emspec_item)
			emspec_item.append(ekwargs)
			emspec_item = tuple(emspec_item)
		new_emspec_list.append(emspec_item)
	emspec_list = new_emspec_list
	# Evaluate exception method list and produce readable test list
	comp_text = '[{0}] {1}.exception({2}) -> {3} ({4})'
	expected_list = list()
	actual_list = list()
	for num, (cobj, kwargs, etype, emsg, ekwargs) in enumerate(emspec_list):
		# Test exception method
		actual_dict = (cobj(**kwargs) if kwargs else cobj()).exception(**ekwargs)
		amsg = actual_dict['msg'] if 'edata' not in actual_dict else putil.check.format_msg(actual_dict['msg'], actual_dict['edata'])
		# Arguments, in the form [argument name]=[argument value] for pretty printing callable call
		arg_text = ', '.join(['{0}={1}'.format(key, putil.misc.strtype(value)) for key, value in ekwargs.items()]) if ekwargs else ''
		# Produce expected and actual pretty printed results
		expected_list.append(comp_text.format(num+offset, cobj, arg_text, etype, emsg))
		actual_list.append(comp_text.format(num+offset, cobj, arg_text, actual_dict['type'], amsg))
	# Produce final actual vs. expected pretty printed list
	expected_msg, actual_msg = '\n'.join(expected_list), '\n'.join(actual_list)
	# Evaluate results
	assert expected_msg == actual_msg


def evaluate_exception_series(init_list, cobj=None, offset=0):	#pylint: disable=R0914
	"""
	Monitor callable(s) for exception raising (exception raised or not, and if it is, type and message)

	:param	init_list: Initialization specification tuple or list of initialization specification tuples. An initialization tuple is of the form (argument dictionary [of the **kwargs form], exception type, exception message) if \
	callable is not specified or (initialization object, argument dictionary, exception type, exception message) otherwise
	:type	init_list: 3 (4)-item tuple or list of 3 (4)-item tuples
	:param	cobj: Object to be called whilst being monitored for exception raising
	:type	cobj: callable
	"""
	# Convert to list if a single tuples is given (if necessary)
	init_list = init_list if isinstance(init_list, list) else [init_list]
	# Add callable object to list of tuples (if necessary)
	init_list = [(cobj, )+init_item for init_item in init_list] if cobj else init_list
	new_init_list = list()
	for init_item in init_list:
		if (len(init_item) == 1) or ((len(init_item) == 2) and (isinstance(init_item[1], dict))):
			init_item = list(init_item)
			init_item += [None, None]
			init_item = tuple(init_item)
		new_init_list.append(init_item)
	init_list = new_init_list
	# Evaluate pairs and produce readable test list
	expected_list = list()
	actual_list = list()
	comp_text = '[{0}] {1}({2}) -> {3}'
	ex_text = '{0} ({1})'
	for num, (cobj, args, extype, exmsg) in enumerate(init_list):
		callable_name = full_callable_name(cobj)
		# Arguments, in the form [argument name]=[argument value] for pretty printing callable call
		arg_text = ', '.join(['{0}={1}'.format(key, putil.misc.strtype(value)) for key, value in args.items()]) if args else ''
		# Exception text of the form [exception type] ([exception message]) for pretty printing result of callable call
		expected_msg = 'DID NOT RAISE' if (extype, exmsg) == (None, None) else ex_text.format(exception_type_str(extype), exmsg)
		# Monitor callable call for exception raising
		try:
			cobj(**args) if args else cobj()	#pylint: disable=W0142
		except:	#pylint: disable=W0702
			eobj = sys.exc_info()
			actual_msg = ex_text.format(exception_type_str(eobj[0]), eobj[1])
		else:
			actual_msg = 'DID NOT RAISE'
		# Produce expected and actual pretty printed results
		expected_list.append(comp_text.format(num+offset, callable_name, arg_text, expected_msg))
		actual_list.append(comp_text.format(num+offset, callable_name, arg_text, actual_msg))
	# Produce final actual vs. expected pretty printed list
	expected_msg, actual_msg = '\n'.join(expected_list), '\n'.join(actual_list)
	# Evaluate results
	assert expected_msg == actual_msg


def evaluate_value_series(cmd, pairs, offset=0, return_or_assert=True):
	""" Evaluates results of a command with multiple argument/value pairs """
	pairs = pairs if isinstance(pairs, list) else [pairs]
	# Evaluate pairs and produce readable test list
	expected_list = list()
	actual_list = list()
	is_callable = '__call__' in dir(cmd)
	for num, (value, expected_result) in enumerate(pairs):
		comp_text = '[{0}] {1}({2}) == {3}' if is_callable and (not isinstance(value, tuple)) else ('[{0}] {1}{2} == {3}' if is_callable else '[{0}] {1} == {2}')
		if is_callable:
			actual_result = cmd(*value) if isinstance(value, tuple) else cmd(value)
			expected_list.append(comp_text.format(num+offset, putil.test.full_callable_name(cmd), putil.misc.strtype(value), expected_result))
			actual_list.append(comp_text.format(num+offset, putil.test.full_callable_name(cmd), putil.misc.strtype(value), actual_result))
		else:
			actual_result = getattr(cmd, value)
			prop_name = '{0}.{1}'.format(cmd, value)
			expected_list.append(comp_text.format(num+offset, prop_name, putil.misc.strtype(expected_result)))
			actual_list.append(comp_text.format(num+offset, prop_name, putil.misc.strtype(actual_result)))
	expected_msg, actual_msg = '\n'.join(expected_list), '\n'.join(actual_list)
	if not return_or_assert:
		return expected_msg, actual_msg
	else:
		assert expected_msg == actual_msg


def exception_type_str(extype):
	"""
	Returns exception type string

	:param	extype: Exception
	:type	extype: type
	:rtype: string
	"""
	return str(extype).split('.')[-1][:-2]


def full_callable_name(cmd):
	""" Introspect full name of command """
	cmd_module = cmd.__module__
	cmd_class = cmd.im_class.__name__ if hasattr(cmd, 'im_class') and getattr(cmd, 'im_class') else ''
	cmd_function = cmd.__name__
	cmd_name = '.'.join(filter(None, [cmd_module, cmd_class, cmd_function]))	#pylint: disable=W0141
	return '{0}.{1}'.format(cmd.im_self, cmd_function) if hasattr(cmd, 'im_self') else cmd_name


def trigger_exception(obj, args, extype, exmsg):
	""" Triggers exception withing the Py.test environment and records value """
	with pytest.raises(extype) as excinfo:
		obj(**args)	#pylint: disable=W0142
	if excinfo.value.message == exmsg:
		return True
	regexp = re.compile(exmsg)
	if regexp.match(excinfo.value.message):
		return True
	print
	print 'Reference message: {0}'.format(exmsg)
	print 'Actual message...: {0}'.format(excinfo.value.message)
	return False


def assert_exception(obj, args, extype, exmsg):
	""" Triggers exception withing the Py.test environment and records value """
	regexp = re.compile(exmsg)
	try:
		with pytest.raises(extype) as excinfo:
			obj(**args)	#pylint: disable=W0142
	except Exception as eobj:	#pylint: disable=W0703
		if eobj.message == 'DID NOT RAISE':
			raise
		eobj_extype = repr(eobj)[:repr(eobj).find('(')]
		if (eobj_extype == exception_type_str(extype)) and ((eobj.message == exmsg) or regexp.match(eobj.message)):
			assert True
		else:
			assert '{0} ({1})'.format(eobj_extype, eobj.message) == '{0} ({1})'.format(exception_type_str(extype), exmsg)
	if (exception_type_str(excinfo.type) == exception_type_str(extype)) and ((excinfo.value.message == exmsg) or regexp.match(excinfo.value.message)):
		assert True
	else:
		assert '{0} ({1})'.format(exception_type_str(excinfo.type), excinfo.value.message) == '{0} ({1})'.format(exception_type_str(extype), exmsg)


def trigger_pcontract_exception(obj, args, exmsg):
	""" Triggers exception withing the Py.test environment and records value """
	with pytest.raises(contracts.ContractNotRespected) as excinfo:
		obj(**args)	#pylint: disable=W0142
	if exmsg not in excinfo.value.error:
		print excinfo.value.error
	return exmsg in excinfo.value.error
